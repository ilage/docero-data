package org.docero.data.processor;

import javax.lang.model.element.*;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;

@SuppressWarnings("WeakerAccess")
class BatchRepositoryBuilder {
    final List<TypeMirror> beans;
    final TypeMirror repositoryInterface;
    final DDataBuilder dataBuilder;
    final String implClassName;
    final List<MethodBehindFacade> methods = new ArrayList<>();

    BatchRepositoryBuilder(DDataBuilder dDataBuilder, TypeElement repositoryElement) {
        dataBuilder = dDataBuilder;
        repositoryInterface = repositoryElement.asType();
        implClassName = repositoryInterface + "_Impl_";
        beans = dDataBuilder.readBeansFromBeanElement(repositoryElement);

        for (Element element : repositoryElement.getEnclosedElements())
            if (element.getKind() == ElementKind.METHOD && !(
                    element.getModifiers().contains(Modifier.DEFAULT) ||
                            element.getModifiers().contains(Modifier.STATIC)
            )) methods.add(new MethodBehindFacade((ExecutableElement) element));
    }

    void generate() throws IOException {
        int simpNameDel = implClassName.lastIndexOf('.');

        HashMap<TypeMirror, BeanData> supported = new HashMap<>();
        for (TypeMirror bean : beans) {
            DataBeanBuilder beanBuilder = dataBuilder.beansByInterface.get(bean.toString());
            DataRepositoryBuilder beanRepository = dataBuilder.repositoriesByBean.get(bean.toString());
            supported.put(bean, new BeanData(beanBuilder, beanRepository));
        }

        try (JavaClassWriter cf = new JavaClassWriter(dataBuilder.environment, implClassName)) {
            String implPackage = implClassName.substring(0, simpNameDel);
            cf.println("package " + implPackage + ";");

            for (BeanData d : supported.values()) {
                String beanPkg = d.bean.interfaceType.toString();
                beanPkg = beanPkg.substring(0, beanPkg.lastIndexOf('.'));
                if (!implPackage.equals(beanPkg))
                    cf.println("import " + beanPkg + ".*;");
            }
            cf.println("import org.apache.ibatis.session.SqlSessionFactory;\n" +
                    "import org.apache.ibatis.session.ExecutorType;");
            if (dataBuilder.spring)
                cf.println("import org.mybatis.spring.SqlSessionTemplate;");
            cf.println("/*\n" +
                    "Class generated by docero-data processor.\n" +
                    "*/\n" +
                    "public final class " +
                    implClassName.substring(simpNameDel + 1)
                    + (dataBuilder.spring ? " extends org.mybatis.spring.support.SqlSessionDaoSupport" : "") +
                    " implements " + repositoryInterface + " {");
            if (dataBuilder.spring) {
                for (BeanData d : supported.values()) {
                    cf.println("private final org.docero.data.DDataRepository<" +
                            d.bean.interfaceType + "," +
                            d.bean.keyType + "> " + d.repository.repositoryVariableName + ";");
                }
                cf.println("\n" +
                        "public " + implClassName.substring(simpNameDel + 1) + "() {\n");
                for (BeanData d : supported.values()) {
                    cf.println("this." + d.repository.repositoryVariableName + " = new " + d.repository.daoClassName + "();");
                }
                cf.println("}\n" +
                        "\n" +
                        "@Override public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {\n" +
                        "super.setSqlSessionTemplate(new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH));");
                for (BeanData d : supported.values()) {
                    cf.println("((org.mybatis.spring.support.SqlSessionDaoSupport)" + d.repository.repositoryVariableName +
                            ").setSqlSessionTemplate((SqlSessionTemplate)this.getSqlSession());");
                }
                cf.println("}\n" +
                        "\n" +
                        "@Override public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) {\n" +
                        "super.setSqlSessionTemplate(sqlSessionTemplate);");
                for (BeanData d : supported.values()) {
                    cf.println("((org.mybatis.spring.support.SqlSessionDaoSupport)" + d.repository.repositoryVariableName +
                            ").setSqlSessionTemplate(sqlSessionTemplate);");
                }
                cf.println("}");
            }
            cf.println("\n" +
                    "@Override public <T extends java.io.Serializable> T create(Class<T> clazz) {\n" +
                    "if(clazz == null) return null;");
            for (BeanData d : supported.values()) {
                cf.println("if (clazz == " + d.bean.interfaceType + ".class) " +
                        "return (T) new " + d.bean.getImplementationName() + "();");
            }
            cf.println("throw new IllegalArgumentException(\"unknown class for repository: \"+clazz.getCanonicalName());\n" +
                    "}\n" +
                    "@Override public <T extends java.io.Serializable> T get(Class<T> clazz, java.io.Serializable id) {\n" +
                    "if(clazz == null || id == null) return null;");
            for (BeanData d : supported.values()) {
                cf.println("if (clazz == " + d.bean.interfaceType + ".class) \n" +
                        "return (T) " + d.repository.repositoryVariableName + ".get((" + d.bean.keyType + ")id);");
            }
            cf.println("throw new IllegalArgumentException(\"unknown class for repository: \"+clazz.getCanonicalName());\n" +
                    "}\n" +
                    "\n" +
                    "@Override public java.util.List<org.apache.ibatis.executor.BatchResult> flushStatements() {\n" +
                    "return ((org.mybatis.spring.SqlSessionTemplate)getSqlSession())" +
                    ".getExecutorType()==ExecutorType.BATCH ? " +
                    "super.getSqlSession().flushStatements() : " +
                    "java.util.Collections.emptyList();\n" +
                    "}\n" +
                    "\n" +
                    "@Override public void insert(java.io.Serializable bean) {\n" +
                    "if(bean == null) return;");
            for (BeanData d : supported.values()) {
                cf.println("else if (bean instanceof " + d.bean.interfaceType + ") " +
                        "" + d.repository.repositoryVariableName + ".insert((" + d.bean.interfaceType + ")bean);");
            }
            cf.println("else throw new IllegalArgumentException(\"unknown class for repository: \"+bean.getClass().getCanonicalName());\n" +
                    "}\n" +
                    "\n" +
                    "@Override public void update(java.io.Serializable bean) {\n" +
                    "if(bean == null)\n return;");
            for (BeanData d : supported.values()) {
                cf.println("else if (bean instanceof " + d.bean.interfaceType + ") " +
                        "" + d.repository.repositoryVariableName + ".update((" + d.bean.interfaceType + ")bean);");
            }
            cf.println("else throw new IllegalArgumentException(\"unknown class for repository: \"+bean.getClass().getCanonicalName());\n" +
                    "}");

            methods.forEach(m -> m.write(cf));

            cf.println("}");
        }
    }

    private class BeanData {
        final DataBeanBuilder bean;
        final DataRepositoryBuilder repository;

        private BeanData(DataBeanBuilder bean, DataRepositoryBuilder repository) {
            this.bean = bean;
            this.repository = repository;
        }
    }

    private class ParamPair {
        final String name;
        final TypeMirror type;

        private ParamPair(String name, TypeMirror type) {
            this.name = name;
            this.type = type;
        }
    }

    private class MethodBehindFacade {
        final String name;
        final TypeMirror type;
        final List<? extends TypeMirror> thrown;
        private final List<ParamPair> parameters;

        MethodBehindFacade(ExecutableElement method) {
            name = method.getSimpleName().toString();
            type = method.getReturnType();
            parameters = method.getParameters().stream()
                    .map(pe -> new ParamPair(pe.getSimpleName().toString(), pe.asType()))
                    .collect(Collectors.toList());
            thrown = method.getThrownTypes();
        }

        public void write(JavaClassWriter cf) {
            try {
                //DataBeanBuilder beanBuilder = dataBuilder.beansByInterface.get(type.toString());
                String returnType;
                DataRepositoryBuilder beanRepository = null;
                boolean returnNothing = type == null || type.getKind() == TypeKind.VOID;
                if (!returnNothing) {
                    returnType = type.toString();
                    beanRepository = dataBuilder.repositoriesByBean.get(returnType);
                } else {
                    returnType = "void";
                }

                if (beanRepository == null)
                    for (TypeMirror bean : beans) {
                        beanRepository = dataBuilder.repositoriesByBean.get(bean.toString());
                        if (beanRepository.methods.stream().anyMatch(m ->
                                (returnNothing ?
                                        (m.returnType == null || m.returnType.getKind() == TypeKind.VOID) :
                                        (m.returnType != null && returnType.equals(m.returnType.toString()))
                                ) &&
                                        m.methodName.equals(name) &&
                                        m.parameters.size() == parameters.size()
                        )) break;
                        else beanRepository = null;
                    }

                if (beanRepository == null) {
                    throw new RuntimeException("can't find repository for method " +
                            name + "(" + parameters.stream()
                            .map(pp -> pp.type.toString())
                            .collect(Collectors.joining(",")) +
                            ") in " + repositoryInterface);
                }

                cf.println("");
                cf.startBlock("@Override public " + returnType + " " + name + "(" +
                        parameters.stream()
                                .map(pp -> pp.type + " " + pp.name)
                                .collect(Collectors.joining(",")) + ") {");
                cf.println((returnNothing ? "" : "return ") +
                        "((" + beanRepository.repositoryInterface +
                        ") " + beanRepository.repositoryVariableName + ")." + name + "(" +
                        parameters.stream()
                                .map(pp -> pp.name)
                                .collect(Collectors.joining(",")) + ");");
                cf.endBlock("}");
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
